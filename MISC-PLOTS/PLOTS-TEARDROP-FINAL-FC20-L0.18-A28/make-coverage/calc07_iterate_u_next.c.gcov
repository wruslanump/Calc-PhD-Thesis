        -:    0:Source:/home/wruslan/workspaces-gnat/gnatstudio-c/gnat_c_cnc-04/src/algo/calc07_iterate_u_next.c
        -:    1:// FILE: calc07_iterate_u_next.c
        -:    2:
        -:    3:#include <stdio.h>
        -:    4:
        -:    5:// INCLUDED FOR THE FUNCTION DEFINITIONS
        -:    6:#include "curves/c_accelern.h"
        -:    7:#include "curves/c_position.h"
        -:    8:#include "curves/c_velocity.h"
        -:    9:
        -:   10:#include "algo/calc07_iterate_u_next.h"
        -:   11:
        -:   12:// double chorderror_tolerance;
        -:   13:
        -:   14:// FILE *FHdata_01;
        -:   15:
        -:   16:double incr_ru_next;
        -:   17:double decr_ru_next;
        -:   18:double ru_next_ratio;
        -:   19:
        -:   20:double ru_next_r1st;
        -:   21:double ru_next_r2nd;
        -:   22:
        -:   23:// ==================================================================
        2:   24:void proc_writeheader_data_calc_u_next (FILE *FHdata_calc_u_next)
        -:   25:// ==================================================================
        -:   26:{
        -:   27:
        2:   28:  fprintf (FHdata_calc_u_next, "# DTStamp_FHdata_calc_u_next %s \n",
        -:   29:           get_datetime_stamp ());
        -:   30:
        2:   31:  fprintf (FHdata_calc_u_next,
        -:   32:           "#rtime[1] u[2] u_next[3] t_interpol[4] first_order[5] "
        -:   33:           "second_order[6] diff[7] pos_x[8] pos_y[9]pos_r[10] eps[11]rho[12] "
        -:   34:           "curr_tang_accn[13] curr_frate[14] frate_limit[15] "
        -:   35:           "x_frate[16] y_frate[17] frate_command[18], diff_frate[19]\n");
        2:   36:}
        -:   37:
        -:   38:// ==================================================================
        2:   39:void proc_writefooter_data_calc_u_next (FILE *FHdata_calc_u_next)
        -:   40:// ==================================================================
        -:   41:{
        -:   42:
        2:   43:  fprintf (FHdata_calc_u_next,
        -:   44:           "#rtime[1] u[2] u_next[3] t_interpol[4] first_order[5] "
        -:   45:           "second_order[6] diff[7] pos_x[8] pos_y[9]pos_r[10] eps[11]rho[12] "
        -:   46:           "curr_tang_accn[13] curr_frate[14] frate_limit[15] "
        -:   47:           "x_frate[16] y_frate[17] frate_command[18], diff_frate[19]\n");
        -:   48:
        -:   49:
        2:   50:  fprintf (FHdata_calc_u_next, "# DTStamp_FHdata_calc_u_next %s \n",
        -:   51:           get_datetime_stamp ());
        2:   52:}
        -:   53:
        -:   54:
        -:   55:// ==================================================================
    22594:   56:void proc_write_calc_u_next (FILE *FHdata_calc_u_next, double rtime, double u,
        -:   57:                        double u_next, double t_interpol, double curr_tang_accn,
        -:   58:                        double curr_frate, double frate_limit, double frate_command)
        -:   59:
        -:   60:// ==================================================================
        -:   61:{
        -:   62:
    22594:   63:  double first_order  = get_u_next_firstorder_runtime (rtime, u, u_next, t_interpol, frate_command);
    22594:   64:  double second_order = get_u_next_secondorder_runtime (rtime, u, u_next, t_interpol, frate_command);
    22594:   65:  double diff = (second_order - first_order);
        -:   66:
    22594:   67:  double cpos_x = fxn_cpos_x (u);
    22594:   68:  double cpos_y = fxn_cpos_y (u);
    22594:   69:  double cpos_r = fxn_cpos_r (u);
        -:   70:
    22594:   71:  double eps = fxn_cpos_epsilon (u, u_next);
    22594:   72:  double rho = fxn_cpos_rho (u);
        -:   73:
        -:   74:  // AVOID JITTER AT MAXIMUM FEEDRATE COMMAND
    22594:   75:  if (curr_frate > frate_command)
        -:   76:    {
     8842:   77:      curr_frate = frate_command;
        -:   78:    }
        -:   79:  // AVOID JITTER AT FEEDRATE LIMIT
    22594:   80:  if (curr_frate > frate_limit)
        -:   81:    {
     6128:   82:      curr_frate = frate_limit;
        -:   83:    }
        -:   84:
        -:   85:  // USE CURR_FRATE (GOOD) FOR X AND Y FEEDRATE COMPONENTS
    22594:   86:  double x_frate = curr_frate * (fxn_cvel_x (u) / fxn_cvel_r (u));
    22594:   87:  double y_frate = curr_frate * (fxn_cvel_y (u) / fxn_cvel_r (u));
    22594:   88:  double AFTER_diff_frate = (frate_limit - curr_frate);
        -:   89:
    22594:   90:  fprintf (FHdata_calc_u_next,
        -:   91:             "%5.3lf %12.9lf %12.9lf %6.3lf %.6e %.6e %.6e %.6e %.6e "
        -:   92:             "%.6e %.6e %.6e %.6e %.12e %.6e %.6e %.6e %.6e %.9e \n",
        -:   93:             rtime, u, u_next, t_interpol, first_order, second_order, diff, cpos_x,
        -:   94:             cpos_y, cpos_r, eps, rho, curr_tang_accn, curr_frate, frate_limit, x_frate, y_frate, frate_command, AFTER_diff_frate);
    22594:   95:}
        -:   96:
        -:   97:
        -:   98:// ==================================================================
    #####:   99:double get_vee_runtime(double ru, double ru_next, double rt_interpol) {
        -:  100:// ==================================================================
        -:  101:
    #####:  102:   double temp1 = pow (fxn_cpos_rho (ru), 2);
    #####:  103:   double temp2 = (fxn_cpos_rho(ru) - fxn_cpos_epsilon(ru, ru_next));
    #####:  104:   double temp3 = pow (temp2, 2);
    #####:  105:   double temp4 = (fabs(sqrt(temp1 - temp3)));
    #####:  106:   double the_rvee = 2*(temp4)/(rt_interpol);
        -:  107:
    #####:  108:   return (the_rvee);
        -:  109:}
        -:  110:// ==================================================================
   112964:  111:double get_u_next_firstorder_runtime(double rtime, double ru, double ru_next, double rt_interpol, double frate_command) {
        -:  112:// ==================================================================
        -:  113:
   112964:  114:    double temp1 = frate_command;
   112964:  115:    double temp2 = temp1 / fxn_cvel_r(ru);
   112964:  116:    double ru_next1st = (rt_interpol)*(temp2);
        -:  117:
   112964:  118:    return (ru_next1st);
        -:  119:}
        -:  120:
        -:  121:// ==================================================================
    #####:  122:double fxn_increase_ru_next_closestto_epsilonlimit (double ru, double ru_next2nd) {
        -:  123:// ==================================================================
        -:  124:double the_incr_ru_next;
        -:  125:
    #####:  126:double ru_next = ru_next2nd;
    #####:  127:double ru_nextstart = ru_next2nd;
    #####:  128:double ru_nextend = 0.000000000000;
    #####:  129:double eps_ru     = 0.000000000000;
    #####:  130:int jump_delta    = 0;
        -:  131:
    #####:  132:double error_tolerance = 1.0E-6;
        -:  133:
    #####:  134:while (fxn_cpos_epsilon(ru, ru_next) <= error_tolerance ){ // LESS THAN
        -:  135:
    #####:  136:    ru_next = ru_next + incr_ru_next;  // PLUS INCREASE (DELTA IS GLOBAL)
    #####:  137:    eps_ru  = fxn_cpos_epsilon(ru, ru_next);
    #####:  138:    jump_delta = jump_delta + 1;
        -:  139:}
        -:  140:
    #####:  141:ru_nextend = (ru_next - incr_ru_next); // ONE STEP BEFORE EXITING LOOP
    #####:  142:ru_next_ratio = (ru_nextend / ru_nextstart);    // GLOBAL unext_ratio
        -:  143:
    #####:  144:        the_incr_ru_next = ru_nextend;
    #####:  145:return (the_incr_ru_next);
        -:  146:}
        -:  147:
        -:  148:// ==================================================================
    #####:  149:double fxn_decrease_ru_next_closestto_epsilonlimit (double ru, double ru_next2nd) {
        -:  150:// ==================================================================
        -:  151:double the_decr_ru_next;
        -:  152:
    #####:  153:double ru_next = ru_next2nd;
    #####:  154:double ru_nextstart = ru_next2nd;
    #####:  155:double ru_nextend = 0.000000000000;
    #####:  156:double eps_ru     = 0.000000000000;
    #####:  157:int jump_delta    = 0;
        -:  158:
    #####:  159:double error_tolerance = 1.0E-6;
        -:  160:
    #####:  161:while (fxn_cpos_epsilon(ru, ru_next) > error_tolerance) { // GREATER THAN
        -:  162:
    #####:  163:    ru_next = ru_next - decr_ru_next;  // MINUS DECREASE (DELTA IS GLOBAL)
    #####:  164:    eps_ru  = fxn_cpos_epsilon(ru, ru_next);
    #####:  165:    jump_delta = jump_delta + 1;
        -:  166:}
        -:  167:
    #####:  168:ru_nextend = (ru_next); // ONE STEP BEFORE EXITING LOOP
    #####:  169:ru_next_ratio = (ru_nextend / ru_nextstart);    // GLOBAL u_step
        -:  170:
    #####:  171:        the_decr_ru_next = ru_nextend;
    #####:  172:return (the_decr_ru_next);
        -:  173:}
        -:  174:
        -:  175:// ==================================================================
    67778:  176:double get_u_next_secondorder_runtime(double rtime, double ru, double ru_next, double rt_interpol, double frate_command) {
        -:  177:// ==================================================================
        -:  178:
    67778:  179:    double temp1 = (rt_interpol)*frate_command;
    67778:  180:    double temp2 = pow (temp1, 2) / 2;
    67778:  181:    double temp3 = fxn_cvel_r (ru);
    67778:  182:    double temp4 = fxn_cacc_r (ru);
    67778:  183:    double temp5 = pow (temp3, 3);
        -:  184:
        -:  185:
    67778:  186:    ru_next_r1st = get_u_next_firstorder_runtime (rtime, ru, ru_next, rt_interpol, frate_command);
    67778:  187:    ru_next_r2nd = ru_next_r1st - (temp2)*(temp4)/(temp5);
        -:  188:
    67778:  189:    return (ru_next_r2nd);
        -:  190:}
        -:  191:
        -:  192:// ==================================================================
        -:  193:// CALCULATION FOR step1_unext IN MAIN
        -:  194:// ==================================================================
        -:  195:// GO TO REDUCE EPS TO BELOW TOLERANCE
     3440:  196:double fxn_get_u_next_with_constrained_eps (double u, double u_next,
        -:  197:                double uppertol_bound,
        -:  198:                int *count_step1_ERROR_1,
        -:  199:                int *count_step1_ERROR_2)
        -:  200:// ==================================================================
        -:  201:{
        -:  202:
     3440:  203:   double inp_u_next = u_next;
        -:  204:   double out_u_next;
     3440:  205:   double theta = 0.999999;
        -:  206:
     3440:  207:   double inp_eps = fxn_cpos_epsilon(u, u_next);
        -:  208:
  2800604:  209:   while (inp_eps > uppertol_bound)
        -:  210:   {
        -:  211:
        -:  212:    // REDUCE u_next
  2797164:  213:    u_next  = u_next*theta;
  2797164:  214:    inp_eps = fxn_cpos_epsilon(u, u_next);   // IMPT CALL TO EPSILON
        -:  215:
  2797164:  216:    theta = theta - 0.000001;
        -:  217:
        -:  218:   }
        -:  219:
     3440:  220:   out_u_next = u_next;
        -:  221:
        -:  222:   // CHECK NO 1
     3440:  223:   if (out_u_next > inp_u_next)
        -:  224:   {
        -:  225:      // ERROR out_u_next SHOULD BE SMALLER THAN inp_u_next because REDUCE
    #####:  226:      printf ("\nERROR: STEP 1, ERROR_1: inp_u_next = %12.9lf inp_u_out = %12.9lf \n", inp_u_next, out_u_next);
    #####:  227:      *count_step1_ERROR_1 += 1;
        -:  228:
        -:  229:   }
        -:  230:
        -:  231:   // CHECK NO 2
     3440:  232:   double check_eps = fxn_cpos_epsilon(u, out_u_next);
     3440:  233:   if (check_eps > uppertol_bound)
        -:  234:   {
        -:  235:      // ERROR IN CONSTRAINING eps BELOW error_tolerance.
    #####:  236:      printf ("\nERROR: STEP 1, ERROR_2: check_eps = %12.9lf uppertol_bound %12.9lf \n", check_eps, uppertol_bound);
    #####:  237:      *count_step1_ERROR_2 += 1;
        -:  238:
        -:  239:   }
        -:  240:
        -:  241:// NOTICE RETURN IS NOT eps BUT u_next HAHAHA.
     3440:  242:return (out_u_next);
        -:  243:
        -:  244:}
        -:  245:
        -:  246:// CALCULATION FOR step2_unext IN MAIN
        -:  247:// ==================================================================
    #####:  248:double fxn_get_u_next_with_eps_both_bounded (
        -:  249:          double u, double u_next, double uppertol_bound, double lowertol_bound,
        -:  250:          int *count_step2_ERROR_1, int *count_step2_ERROR_2,
        -:  251:          int *count_step2_ERROR_3, int *count_step2_ERROR_4 )
        -:  252:// ==================================================================
        -:  253:{
    #####:  254:  double step2_unext = u_next;   // SETTING FOR TEST ONLY
    #####:  255:  double inp_u_next  = u_next;
        -:  256:  double out_u_next;
    #####:  257:  double theta = 1.0000000;
        -:  258:
        -:  259:  // GET INITIAL EPSILON
    #####:  260:  double inp_eps = fxn_cpos_epsilon (u, u_next);
        -:  261:
        -:  262:  // RUN A WHILE LOOP ALGORITHM
    #####:  263:  while  (inp_eps < lowertol_bound)
        -:  264:   {
        -:  265:
        -:  266:    // INCREASE u_next INCREMENTALLY
    #####:  267:    u_next = u_next * theta;
        -:  268:
        -:  269:    // IMPT CALL TO EPSILON
    #####:  270:    inp_eps = fxn_cpos_epsilon(u, u_next);
        -:  271:
        -:  272:    // INCREMENTAL VALUE (1E-7)
        -:  273:    // MUST BE SMALLER THAN UPPER BOUND TOLERANCE
    #####:  274:    theta = theta + 0.0000001;
        -:  275:
        -:  276:   }
        -:  277:
        -:  278:  // LOOP EXITS WHEN CONDITION (inp_eps < lowertol_bound) FAILS.
        -:  279:  // MEANING inp_eps > lowertol_bound. This is what we want.
        -:  280:  // IMPT: (u_next IS THE VALUE AT EXIt OF while (...) loop
    #####:  281:  out_u_next = u_next;
        -:  282:
        -:  283:
        -:  284:   // CHECK THAT EPS IS BELOW UPPERTOL_BOUND
    #####:  285:   double check_eps = fxn_cpos_epsilon(u, out_u_next);
    #####:  286:   if (check_eps > uppertol_bound)
        -:  287:     {
    #####:  288:      printf ("\nERROR: STEP 2, ERROR 1: FAILED UPPER BOUND : check_eps = %12.9lf out_u_next = %12.9lf \n", check_eps, out_u_next);
    #####:  289:      *count_step2_ERROR_1 += 1;
        -:  290:
        -:  291:      }
        -:  292:
        -:  293:   // CHECK THAT EPS IS ABOVE LOWERTOL_BOUND
    #####:  294:   if (check_eps < lowertol_bound)
        -:  295:     {
    #####:  296:      printf ("\nERROR: STEP 2, ERROR 2: FAILED LOWER BOUND : check_eps = %12.9lf out_u_next = %12.9lf \n", check_eps, out_u_next);
    #####:  297:      *count_step2_ERROR_2 += 1;
        -:  298:
        -:  299:
        -:  300:      }
        -:  301:
        -:  302:   // CHECK THAT BOTH CONDITIONS ARE TRUE SIMULTANEOUSLY
    #####:  303:   if ( (check_eps < uppertol_bound) && (check_eps > lowertol_bound) )
        -:  304:     {
        -:  305:       // Important theory.
        -:  306:       // If check_eps is good, so the corresponding out_u_next is also good.
        -:  307:       // Note we ASSIGN out_u_next AS OUTPUT and NOT the corresponding check_eps.
    #####:  308:       step2_unext = out_u_next;
        -:  309:
        -:  310:     } else  {
    #####:  311:          printf ("\nERROR: STEP 2, ERROR 3: FAILED BOTH UPPER AND LOWER BOUNDS.\n");
    #####:  312:          *count_step2_ERROR_3 += 1;
        -:  313:     }
        -:  314:
        -:  315:  // NOTE: *count_step2_ERROR_4 RESERVED FOR FUTURE USE
        -:  316:
        -:  317:  // RETURN ONLY WHEN PASS BOTH BOUNDS
    #####:  318:  return (step2_unext);
        -:  319:
        -:  320:}
        -:  321:
        -:  322:// ==================================================================
        -:  323:// ALHAMDULILLAH 3 TIMES WRY
        -:  324:// ==================================================================
