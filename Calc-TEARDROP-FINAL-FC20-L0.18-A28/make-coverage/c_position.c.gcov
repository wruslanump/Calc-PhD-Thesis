        -:    0:Source:/home/wruslan/workspaces-gnat/gnatstudio-c/gnat_c_cnc-04/src/curves/c_position.c
        -:    1:
        -:    2:// FILE: c_position.c
        -:    3:#include <math.h>
        -:    4:
        -:    5:
        -:    6:#include "curves/c_position.h"
        -:    7:#include "curves/c_pos_epsilon.h"
        -:    8:#include "curves/c_pos_rho.h"
        -:    9:
        -:   10:
        -:   11:double const PI_cpos = 3.141592653589793238;
        -:   12:
        -:   13:double cu_step;
        -:   14:// double chorderror_tolerance;
        -:   15:
        -:   16:// ==================================================================
        -:   17:// X-POSITION COMPONENT
        -:   18:// ==============================================
   326212:   19:double fxn_cpos_x(double u) 
        -:   20:  {
        -:   21:
        -:   22:// ELLIPSE X
   326212:   23:  double scaleup = 11.0;
   326212:   24:  double k = (2.0 * PI_cpos);
   326212:   25:  double x = sin(k*u);
   326212:   26:  return (scaleup)*(x);
        -:   27:
        -:   28:    /*
        -:   29:    // ===============================
        -:   30:    // RIBBON100L - X AXIS
        -:   31:    // FOR RIBBON10L, CHANGE scaleup = 1.0 
        -:   32:
        -:   33:  // set xrange [-1.0:+6.0] GnuPlot
        -:   34:  // set yrange [-1.0:+6.0] Gnuplot
        -:   35:  // RANGE FOR t = [-2.00, +2.00] equivalent to u = [0.00, 1.00]
        -:   36:  double t = 4.0*(u - 0.50); // TRANSORMATION EQUATION
        -:   37: 
        -:   38:  double scaleup = 10.0;
        -:   39:  double x = (t*t);
        -:   40:  return (scaleup)*(x);
        -:   41:*/
        -:   42: // ===============================
        -:   43:/*    
        -:   44: 
        -:   45:  // TEARDROP X
        -:   46:  double scaleup = 1.0;
        -:   47:  return (scaleup)*( -150.0*pow(u, 1.0) + 450.0*pow(u, 2.0) - 300.0*pow(u, 3.0) );
        -:   48:*/
        -:   49:// ================================
        -:   50:/*
        -:   51:  // HYPOTROCOID X
        -:   52:  double scaleup = 1.0;     // 1.0 IS GOOD (OTHERS BAD)
        -:   53:  double k = (6.0*PI_cpos);
        -:   54:  double x = (2*cos(k*u) + 5*cos(2*k*u/3));
        -:   55:  return (scaleup)*(x);
        -:   56:*/
        -:   57:// ================================
        -:   58:/*  
        -:   59:  // EPICYCLOID X
        -:   60:  double scaleup = 10.0;
        -:   61:  double k = (2.0 * PI_cpos);
        -:   62:  double small = 1.0e-10; 
        -:   63:  double x =  (5*cos(k*u + small) - cos(5*k*u - small));     // X
        -:   64:  return (scaleup)*(x);
        -:   65:*/
        -:   66:// =================================
        -:   67:/*
        -:   68: // ASTEPI X = ASTROID X + EPICYCLOID X
        -:   69:  double scaleup = 10.0;
        -:   70:  double k = (2.0 * PI_cpos);
        -:   71:  double small = 1.0e-10;
        -:   72:
        -:   73:  double x_ast = +4.0*pow(sin(k*u), 3.0);
        -:   74:  double x_epi = +5.0*cos(k*u + small) - cos(5*k*u - small); 
        -:   75:  double x = x_ast + x_epi;
        -:   76:  return (scaleup)*(x);
        -:   77:*/
        -:   78:// =================================
        -:   79:/*
        -:   80:  // SNAHYP X = SNAILSHELL X + HYPOTROCOID
        -:   81:  double scaleup = 10.0;
        -:   82:  double k = (4.0 * PI_cpos);
        -:   83:  double small = 1.0e-10;
        -:   84:  double x_sna = (4.0)*( sin(2*k*u) / (k*u*k*u + 4.0) );
        -:   85:  double x_hyp = (2*cos(k*u) + 5*cos(2*k*u/3));
        -:   86:  double x = x_sna + x_hyp;
        -:   87:  return (scaleup)*(x);
        -:   88:*/
        -:   89:// =================================
        -:   90:/* 
        -:   91:  // CIRCLE X
        -:   92:  double scaleup = 79.0;
        -:   93:  double k = (2.0 * PI_cpos);
        -:   94:  double x = sin(k*u);
        -:   95:  return (scaleup)*(x);
        -:   96:*/
        -:   97:// ==================================
        -:   98:/*
        -:   99:  // LINE-POLYU X
        -:  100:  double scaleup = 1.0;
        -:  101:  double polyu_x = ( 150.0*pow(u, 1.0) + 150.0*pow(u, 2.0) );
        -:  102:  return (scaleup)*(polyu_x);
        -:  103:*/
        -:  104:// ==================================
        -:  105:/*
        -:  106:    // https://en.wikipedia.org/wiki/Astroid
        -:  107:    // SKEWED ASTROID X
        -:  108:    double scaleup = 10.0;
        -:  109:    double k = (2.0 * PI_cpos);
        -:  110:    double x =   +4.0*pow(sin(k*u), 3.0);
        -:  111:    // double dx_du =  +4.0*(3.0)*k*pow(cos(k*u), 2.0);
        -:  112:    // double d2x_du2 = -4.0*(3.0)*(2.0)*k*k*pow(sin(k*u), 1.0);
        -:  113:    return (scaleup)*(x);
        -:  114:*/
        -:  115:  
        -:  116:// ===================================
        -:  117:/*
        -:  118:  // SNAILSHELL X
        -:  119:  double scaleup = 100.0;
        -:  120:  double k = (3.0*PI_cpos);
        -:  121:  double x = ( sin(2*k*u) / (k*u*k*u + 4.0) );
        -:  122:  return (scaleup)*(x);
        -:  123:*/
        -:  124:// ===================================
        -:  125:/* 
        -:  126:  // BUTTERFLY X
        -:  127:  double scaleup = 10.0;
        -:  128:  double k = (2.0*PI_cpos);
        -:  129:  double x = ( sin(k*u) * ( exp(cos(k*u))  - 2*cos(4*k*u) - pow(sin(k*u/12), 5.0) ));
        -:  130:  return (scaleup)*(x);
        -:  131:*/
        -:  132:
        -:  133:} 
        -:  134:// ==================================================================
        -:  135:// Y-POSITION COMPONENT
        -:  136:// ==================================================================
   326212:  137:double fxn_cpos_y (double u)
        -:  138:  {
        -:  139:
        -:  140:
        -:  141:
        -:  142: // ELLIPSE Y
   326212:  143:  double scaleup = 51.0;
   326212:  144:  double k = (2.0 * PI_cpos);
   326212:  145:  double y = cos(k*u);
   326212:  146:  return (scaleup)*(y);
        -:  147:
        -:  148:  /* 
        -:  149:    
        -:  150:  // ===============================  
        -:  151:  // RIBBON100L - Y AXIS
        -:  152:  // set xrange [-1.0:+6.0] GnuPlot
        -:  153:  // set yrange [-1.0:+6.0] Gnuplot
        -:  154:  // RANGE FOR t = [-2.00, +2.00] equivalent to u = [0.00, 1.00]
        -:  155:  double t = 4.0*(u - 0.50); // TRANSORMATION EQUATION
        -:  156:
        -:  157:  double scaleup = 10.0;
        -:  158:  double y = (t*t*t) - 3*(t) + 3;
        -:  159:  return (scaleup)*(y);
        -:  160:
        -:  161: // ===============================
        -:  162:*/
        -:  163:/* 
        -:  164:  // TEARDROP Y
        -:  165:  double scaleup = 1.0;
        -:  166:  return (scaleup)*( -150.0*pow(u, 1.0) + 150.0*pow(u, 2.0) );
        -:  167:*/
        -:  168:  // =================================
        -:  169:/*
        -:  170:  // HYPOTROCOID Y
        -:  171:  double scaleup = 1.0;    // 1.0 IS GOOD (OTHERS BAD)
        -:  172:  double k = (6.0*PI_cpos);
        -:  173:  double y = (2*sin(k*u) - 5*sin(2*k*u/3));
        -:  174:  return (scaleup)*(y);
        -:  175:*/
        -:  176:  // ==================================  
        -:  177:/*
        -:  178:  // EPICYCLOID Y
        -:  179:  double scaleup = 10.0;
        -:  180:  double k = (2.0*PI_cpos);                      // RANGE
        -:  181:  double small = 1.0e-10;
        -:  182:  double y = ( 5*sin(k*u + small) - sin(5*k*u - small) );    // Y
        -:  183:  return (scaleup)*(y);
        -:  184:*/
        -:  185:// ==================================
        -:  186:/*
        -:  187:// ASTEPI Y = ASTROID Y + EPICYCLOID Y
        -:  188:  double scaleup = 10.0;
        -:  189:  double k = (2.0 * PI_cpos);
        -:  190:  double small = 1.0e-10;
        -:  191:
        -:  192:  double y_ast = +4.0*pow(cos(k*u), 3.0);
        -:  193:  double y_epi = +5.0*sin(k*u + small) - sin(5*k*u - small) ;
        -:  194:  double y = y_ast + y_epi;
        -:  195:  return (scaleup)*(y);
        -:  196:*/
        -:  197:// ==================================
        -:  198:/*
        -:  199:  // SNAHYP Y = (10)*SNAILSHELL Y + HYPOTROCOID Y
        -:  200:  double scaleup = 10.0;
        -:  201:  double k = (4.0 * PI_cpos);
        -:  202:  double small = 1.0e-10;
        -:  203:  double y_sna = (10)*(cos(2*k*u) / (k*u*k*u + 4.0));
        -:  204:  double y_hyp = (2*sin(k*u) - 5*sin(2*k*u/3));
        -:  205:  double y = y_sna + y_hyp;
        -:  206:  return (scaleup)*(y);
        -:  207:*/
        -:  208:// ==================================
        -:  209:  /*
        -:  210:   // CIRCLE Y
        -:  211:    double scaleup = 79.0;
        -:  212:    double k = (2.0 * PI_cpos);
        -:  213:    double y = cos(k*u);
        -:  214:    return (scaleup)*(y);
        -:  215:
        -:  216:*/
        -:  217:// ==================================
        -:  218:/*
        -:  219:  // LINE-POLYU Y
        -:  220:  double scaleup = 1.0;
        -:  221:  double polyu_y = ( 150.0*pow(u, 1.0) + 150.0*pow(u, 2.0) );
        -:  222:  return (scaleup)*(polyu_y);
        -:  223:*/
        -:  224:// ==================================
        -:  225:/*
        -:  226:  // SKEWED ASTROID Y
        -:  227:  double scaleup = 25.0;
        -:  228:  double k = (2.0*PI_cpos);
        -:  229:  double y   = +4.0*pow(cos(k*u), 3.0);
        -:  230:  // double dy_du  = -4.0*(3.0)*k*pow(sin(k*u), 2.0):
        -:  231:  // double d2y_du2 = -4.0*(3.0)*(2.0)*k*k*pow(cos(k*u), 1.0):
        -:  232:  return (scaleup)*(y);
        -:  233:*/
        -:  234:// ===================================
        -:  235:/*
        -:  236:  // SNAILSHELL Y
        -:  237:  double scaleup = 100.0;
        -:  238:  double k = (3.0*PI_cpos);
        -:  239:  double y = (cos(2*k*u) / (k*u*k*u + 4.0));
        -:  240:  return (scaleup)*(y);
        -:  241:*/
        -:  242:// ====================================
        -:  243:/*
        -:  244:  // BUTTERFLY Y
        -:  245:  double scaleup = 10.0;
        -:  246:  double k = (2.0*PI_cpos);
        -:  247:  double y = ( cos(k*u)*( exp(cos(k*u)) -2*cos(4*k*u) - pow(sin(k*u/12), 5.0)));
        -:  248:  return (scaleup)*(y);
        -:  249:*/
        -:  250:  
        -:  251:  }
        -:  252:
        -:  253:// ==============================================  
        -:  254:// R-POSITION VECTOR RADIUS OR MAGNITUDE
        -:  255:// ==============================================
   112968:  256:double fxn_cpos_r (double u)
        -:  257:  {
   112968:  258:  double temp_px = fxn_cpos_x (u);
   112968:  259:  double temp_py = fxn_cpos_y (u);
   112968:  260:  double temp_pr = sqrt(temp_px*temp_px + temp_py*temp_py);
        -:  261:  
   112968:  262:  return ( fabs(temp_pr) ); 
        -:  263:  }
        -:  264:
        -:  265:
        -:  266:// ==============================================
    #####:  267:double fxn_cpos_magn(double u) {
    #####:  268:	return (fxn_cpos_r(u));
        -:  269:}
        -:  270:
        -:  271:
        -:  272:// X-POSITION UNIT VECTOR
        -:  273:// ==============================================
    #####:  274:double fxn_cpos_uvect_x(double u) {
    #####:  275:	return (fxn_cpos_x(u)/fxn_cpos_r(u));
        -:  276:}
        -:  277:
        -:  278:// Y-POSITION UNIT VECTOR
        -:  279:// ==============================================
    #####:  280:double fxn_cpos_uvect_y(double u) {
    #####:  281:	return (fxn_cpos_y(u)/fxn_cpos_r(u));
        -:  282:}
        -:  283:
        -:  284:// ANGLE POSITION VECTOR IN RADIANS COUNTER-CLOCKWISE 
        -:  285:// ==============================================
    #####:  286:double fxn_cpos_theta_rad(double u) {
    #####:  287:	return (atan(fxn_cpos_y(u)/fxn_cpos_x(u)));
        -:  288:}
        -:  289:
        -:  290:// ANGLE POSITION VECTOR IN DEGREES 
        -:  291:// ===============================================
    #####:  292:double fxn_cpos_theta_deg(double u) {
    #####:  293:	return ( fxn_cpos_theta_rad(u)*(180.0/PI_cpos) );
        -:  294:}
        -:  295:
        -:  296:// POSITION CHORD ERROR = EPSILON  
        -:  297:// =================================================
  3120354:  298:double fxn_cpos_epsilon(double u, double u_next) {
        -:  299:
  3120354:  300:   double the_epsilon = fxn_c_epsilon_for_arc_u_to_u_next(u, u_next, arc_u_points, arc_x_points,  arc_y_points);
  3120354:  301:	return (the_epsilon);
        -:  302:}
        -:  303:
        -:  304:// POSITION RADIUS OF CURVATURE = RHO 
        -:  305:// =================================================
   338904:  306:double fxn_cpos_rho(double u) {
        -:  307:
        -:  308:    // FUNCTION DEFINED IN cpos_rho.h HEADER FILE
   338904:  309:	return (fxn_c_radiuscurvature_rho_at_u(u)); 
        -:  310:}
        -:  311:
        -:  312:// POSITION CURVATURE OF THE CURVE = K = (1.0/RHO)
        -:  313:// =================================================
    #####:  314:double fxn_cpos_curvature(double u) {
        -:  315:
    #####:  316: 	return ( 1.0/fxn_cpos_rho(u) );
        -:  317:}
        -:  318:
        -:  319:// ==================================================================
    45188:  320:double fxn_calc_deltaS_use_rho_eps (double u, double u_next)
        -:  321:// ==================================================================
        -:  322:{
        -:  323:  double deltaS;
        -:  324:
    45188:  325:  double the_rho = fxn_cpos_rho(u + (u_next/2.0));
    45188:  326:  double the_eps = fxn_cpos_epsilon(u, u_next);
    45188:  327:  double temp1 = (the_rho*the_rho) - (the_rho - the_eps)*(the_rho - the_eps);
    45188:  328:  deltaS = (2.0)*pow(temp1, 0.5);
        -:  329:
    45188:  330:  return (deltaS); // should be equivalent to chordlength
        -:  331: } 
        -:  332:// ==================================================================
    45188:  333:double fxn_calc_chordlength_use_paramcurve (double u, double u_next)
        -:  334:// ==================================================================
        -:  335:{
        -:  336:  double chordlength;
        -:  337:  double x1, x2, y1, y2;
        -:  338:
        -:  339:  // Use param curve and geometry
    45188:  340:  x1 = fxn_cpos_x (u);
    45188:  341:  y1 = fxn_cpos_y (u);
    45188:  342:  x2 = fxn_cpos_x(u+u_next);
    45188:  343:  y2 = fxn_cpos_y(u+u_next);
        -:  344:
    45188:  345:  chordlength = fabs (sqrt (pow ((x2 - x1), 2.0) + pow ((y2 - y1), 2.0)));
        -:  346:
    45188:  347:  return (chordlength); // should be equivalent to deltaS
        -:  348:}
        -:  349:
        -:  350:// ==================================================================
    #####:  351:double fxn_calc_eps_use_paramcurve (double u, double u_next)
        -:  352:// ==================================================================
        -:  353:{
        -:  354:   double the_eps;
        -:  355:
        -:  356:   // FULL CODES INSIDE:
        -:  357:   // curves/c_position.h and curves/c_pos_epsilon.h
        -:  358:
    #####:  359:   the_eps = fxn_cpos_epsilon(u, u_next);
        -:  360:
        -:  361:   // Manual calculation geometrically using parametric curve.
        -:  362:   // Find position of chord endpoints (x1,y1) and (x2,y2) for parameter
        -:  363:   // at u and u+u_next, respectively.
        -:  364:   // Divide the chord into 20 linear segments of equal length.
        -:  365:   // At each point on the divided segment, construct a perpendicular
        -:  366:   // line to the chord. Find the intersection point of this perpendicular
        -:  367:   // line to the curve (arc). Calculate the distance from the point
        -:  368:   // on the chord to the curve. The value of epsilon is the maximum of
        -:  369:   // the 20 distances calculated.
        -:  370:
    #####:  371:   return (the_eps);
        -:  372:}
        -:  373:
        -:  374:// ==================================================================
    #####:  375:double fxn_calc_rho_use_paramcurve (double u, double u_next)
        -:  376:// ==================================================================
        -:  377:{
        -:  378:   double the_rho;
        -:  379:
        -:  380:   // FULL CODES INSIDE:
        -:  381:   // curves/c_position.h and curves/c_pos_epsilon.h
        -:  382:
        -:  383:   // REF: https://math24.net/curvature-radius.html
        -:  384:   // USING THE FORMULA AT THE REF ABOVE
    #####:  385:   the_rho = fxn_cpos_rho(u);
        -:  386:
    #####:  387:   return (the_rho);
        -:  388:
        -:  389:}
        -:  390:// ==================================================================
        -:  391:double fxn_calc_deg_to_rad(double angle_deg);
    #####:  392:double fxn_calc_deg_to_rad(double angle_deg)
        -:  393:{
    #####:  394:double result = angle_deg*(PI_cpos/180.0);
    #####:  395:return(result);
        -:  396:}
        -:  397:// ==================================================================
        -:  398:
    #####:  399:double fxn_calc_rad_to_deg(double angle_rad)
        -:  400:{
    #####:  401:	double result = angle_rad*(180.0/PI_cpos);
    #####:  402:return(result);
        -:  403:}
        -:  404:
        -:  405:// REFERENCE:
        -:  406:// https://www.engineersedge.com/math/circular_segment_equation_and_calculator__13796.htm
        -:  407:// ==================================================================
    22592:  408:double fxn_calc_arc_length(int N, double u, double u_next, double chord_length, double eps, double rho)
        -:  409:// ==================================================================
        -:  410:{
        -:  411:
        -:  412:  // LOCAL VARIABLES
    22592:  413:  double arc_length = 0.0;
        -:  414:
        -:  415:  // CHECK INPUT PARAMETERS
        -:  416:  // printf ("GOOD FXN DEBUG: N \t\t\t= %d \n", N);
        -:  417:  // printf ("GOOD FXN DEBUG: u \t\t\t= %lf \n", u);
        -:  418:  // printf ("GOOD FXN DEBUG: u_next \t\t= %lf \n", u_next);
        -:  419:  // 
        -:  420:  // printf ("GOOD FXN DEBUG: chord_length \t\t= %.12e \n", chord_length);
        -:  421:  // printf ("GOOD FXN DEBUG: eps \t\t\t= %.12e \n", eps);
        -:  422:  // printf ("GOOD FXN DEBUG: rho \t\t\t= %.12e \n", rho);
        -:  423:
        -:  424:
        -:  425:  // RAW GEOMETRIC CALCULATION ARC LENGTH OF PARAMETRIC CURVES
    22592:  426:   double dx_du = fxn_cvel_x(u);
    22592:  427:   double dy_du = fxn_cvel_y(u);
    22592:  428:   double sumsquare = (dx_du)*(dx_du) + (dy_du)*(dy_du);
    22592:  429:   double arc_length0 = (u_next)*sqrt(sumsquare);
        -:  430:
        -:  431:// printf("arc_length0 \t\t\t= %.12e \n", arc_length0);
        -:  432:// isnan (arc_length0) 
        -:  433://      ? printf ("arc_length0 is NaN \t\t= Not a Number \n") 
        -:  434://      : printf ("arc_length0 is \t\t= REAL \n");
        -:  435:   
    22592:  436:   arc_length = fabs(arc_length0);
        -:  437:  
    22592:  438:return (arc_length);
        -:  439:}
        -:  440:
        -:  441:// ==================================================================
    45184:  442:double fxn_calc_arc_theta(int N, double u, double chord_length, double eps, double rho)
        -:  443:// ===================================================================
        -:  444:{
        -:  445:  // CHECK INCOMING VALUES
        -:  446:  // printf("GOOD arc_theta: chord_length \t\t= %.12e \n", chord_length);
        -:  447:  // printf("GOOD arc_theta: eps \t\t\t= %.12e \n", eps);
        -:  448:  // printf("GOOD arc_theta: rho \t\t\t= %.12e \n", rho);
        -:  449:     
    45184:  450:   double arc_theta = 0.0; 
    45184:  451:   double arg_arcsine = chord_length/(2.0*rho);
        -:  452:  
        -:  453:   // printf("DEBUG: arg_arcsine = %lf \n", arg_arcsine );
    45184:  454:   if ( (arg_arcsine < -1.0) || (arg_arcsine > +1.0) ) 
        -:  455:   {
        4:  456:      printf("ERROR ERROR ERROR: Angle_theta: arg_arcsine is out of range [-1.0 : +1.0] arg_arcsine = %.12e \n", arg_arcsine );
        -:  457:   } else {
    45180:  458:      arc_theta = 2.0*asin(arg_arcsine);
        -:  459:      // printf("GOOD FXN OUTPUT: Angle arc_theta \t= %.12e (rad) \n", arc_theta);
        -:  460:   }
        -:  461:
    45184:  462:return(arc_theta);
        -:  463:}
        -:  464:
        -:  465:
        -:  466:// ==================================================================
    22592:  467:double fxn_calc_arc_area(int N, double u, double chord_length, double eps, double rho)
        -:  468:// ===================================================================
        -:  469:{
        -:  470:
        -:  471:   // CHECK INCOMING VALUES
        -:  472:   // printf("GOOD arc_area: chord_length \t\t= %.12e \n", chord_length);
        -:  473:   // printf("GOOD arc_area: eps \t\t\t= %.12e \n", eps);
        -:  474:   // printf("GOOD arc_area: rho \t\t\t= %.12e \n", rho);
        -:  475:
    22592:  476:   double arc_area = 0.0;
        -:  477:
        -:  478:   // CALLING A FUNCTION
    22592:  479:   double arc_theta = fxn_calc_arc_theta(N, u, chord_length, eps, rho);
        -:  480:   // printf("GOOD arc_area: arc_theta \t\t= %.12e \n", arc_theta);
        -:  481:   // printf("GOOD arc_area: sin(arc_theta) \t\t= %.12e \n", sin(arc_theta));
        -:  482:
    22592:  483:   double DIFF = arc_theta - sin (arc_theta);
        -:  484:   // printf ("GOOD arc_area: DIFF \t\t\t= %.12e \n", DIFF);
        -:  485:   // printf ("GOOD arc_area: rho*rho/2 \t\t= %.12e \n", rho*rho/2);
        -:  486:      
        -:  487:   // CALC ARC AREA
    22592:  488:   arc_area = (rho*rho)/2 * (DIFF);
        -:  489:   // printf("GOOD FXN OUTPUT: arc_area \t\t= %.12e (mm2) \n", arc_area);
        -:  490:   
        -:  491:  
    22592:  492:return(arc_area);
        -:  493:}
        -:  494:
        -:  495:
        -:  496:
        -:  497:
        -:  498:// ==================================================================
        -:  499:// ALHAMDULILLAH WRY.
        -:  500:// ==================================================================
        -:  501:
        -:  502:
